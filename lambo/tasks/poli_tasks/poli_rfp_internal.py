"""
Wrap task setup to set variables of the observer.
Extends basic lambo task: ProxyRFPTask
"""
import logging
from pathlib import Path
import numpy as np
from poli.core.util import batch
from poli.core.util.external_observer import ExternalObserver

import lambo
from lambo.tasks.proxy_rfp.proxy_rfp import ProxyRFPTask
from poli.objective_repository.foldx_rfp_lambo import RFPWrapperFactory
from poli.objective_repository.foldx_rfp_lambo import ALGORITHM, STARTING_N, BATCH_SIZE

# TODO: integrate this into the task class
# NOTE: this has to run as a dedicated process. Otherwise observer does not work.
observer = ExternalObserver()


class PoliRFPInternal(ProxyRFPTask):
    def __init__(
        self,
        tokenizer,
        candidate_pool,
        obj_dim,
        transform=lambda x: x,
        num_start_examples=None,
        **kwargs,
    ):
        super().__init__(
            tokenizer, candidate_pool, obj_dim, transform, num_start_examples, **kwargs
        )

    def task_setup(self, config, project_root, *args, **kwargs):
        if project_root is None:
            project_root = str(Path(lambo.__file__).parent.parent.resolve())
        base_candidates, base_targets, all_seqs, all_targets = super().task_setup(
            config, project_root=project_root, *args, **kwargs
        )
        problem_information = RFPWrapperFactory().get_setup_information()
        # This is set by hydra config - for vanilla lambo OOB experiments
        seed = config.seed
        batch_size = config.task.batch_size
        num_start_examples = config.task.num_start_examples
        # NOTE: this is hydra loaded by Lambo internally, taken from trial_id OR if None randomly generated by upcycle scripting-tools
        logging.info(
            f"Calling reference RFP Task:\n seed={seed}, N={num_start_examples}, B={batch_size}"
        )
        observer.initialize_observer(
            problem_information,
            {
                ALGORITHM: "LAMBO",
                STARTING_N: num_start_examples,
                BATCH_SIZE: batch_size,
            },
            all_seqs,
            all_targets,
            seed,
        )
        return base_candidates, base_targets, all_seqs, all_targets

    def score(self, candidates):
        y = super().score(candidates)
        for i in range(len(candidates)):
            observer.observe(
                np.array([candidates[i].mutant_residue_seq]), y[i : i + 1, ...]
            )
        return y
